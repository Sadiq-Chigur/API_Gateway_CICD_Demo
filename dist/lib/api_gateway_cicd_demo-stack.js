"use strict";
/*
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';
import * as lambda from 'aws-cdk-lib/aws-lambda';
import * as apigateway from 'aws-cdk-lib/aws-apigateway';
import * as path from 'path';
import * as fs from 'fs';

export class ApiGatewayCicdDemoStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    const helloFn = new lambda.Function(this, 'HelloFunction', {
      runtime: lambda.Runtime.NODEJS_18_X,  // <- Fix here
      handler: 'hello.handler',
      code: lambda.Code.fromAsset(path.join(__dirname, '../lambda')),
    });

    const userFn = new lambda.Function(this, 'UserFunction', {
      runtime: lambda.Runtime.NODEJS_18_X,
      handler: 'user.handler',
      code: lambda.Code.fromAsset(path.join(__dirname, '../lambda')),
    });

    // Load and inject ARNs into OpenAPI spec
    const rawSpec = fs.readFileSync('api-definition.json', 'utf8');
    const spec = rawSpec
      .replace('REPLACE_HELLO_URI', `arn:aws:apigateway:${this.region}:lambda:path/2015-03-31/functions/${helloFn.functionArn}/invocations`)
      .replace('REPLACE_USER_URI', `arn:aws:apigateway:${this.region}:lambda:path/2015-03-31/functions/${userFn.functionArn}/invocations`);
    const openApiSpec = JSON.parse(spec);

    const restApi = new apigateway.SpecRestApi(this, 'RestApiFromJson', {
      apiDefinition: apigateway.ApiDefinition.fromInline(openApiSpec),
      deployOptions: {
        stageName: 'dev',
      },
    });

    helloFn.grantInvoke(new cdk.aws_iam.ServicePrincipal('apigateway.amazonaws.com'));
    userFn.grantInvoke(new cdk.aws_iam.ServicePrincipal('apigateway.amazonaws.com'));

    new cdk.CfnOutput(this, 'APIEndpoint', {
      value: `${restApi.url}hello`,
    });
  }
}
*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiGatewayCicdDemoStack = void 0;
/*
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';
import * as lambda from 'aws-cdk-lib/aws-lambda';
import * as apigateway from 'aws-cdk-lib/aws-apigateway';
import * as fs from 'fs';
import * as path from 'path';

export class ApiGatewayCicdDemoStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    const lambdaPath = path.join(__dirname, '../lambda');

    const resourceMap: Record<string, string> = JSON.parse(
      fs.readFileSync('resource-map.json', 'utf8')
    );

    const lambdaFns: Record<string, lambda.Function> = {};

    // Step 1: Create Lambda functions dynamically
    for (const [placeholder, handler] of Object.entries(resourceMap)) {
      const logicalName = handler.replace(/[^\w]/g, '') + 'Fn';

      lambdaFns[placeholder] = new lambda.Function(this, logicalName, {
        runtime: lambda.Runtime.NODEJS_18_X,
        handler: handler,
        code: lambda.Code.fromAsset(lambdaPath),
      });

      lambdaFns[placeholder].grantInvoke(
        new cdk.aws_iam.ServicePrincipal('apigateway.amazonaws.com')
      );
    }

    // Step 2: Read OpenAPI JSON and inject Lambda ARNs
    let openApiJson = fs.readFileSync('api-definition.json', 'utf8');

    for (const [placeholder, fn] of Object.entries(lambdaFns)) {
      const uri = `arn:aws:apigateway:${this.region}:lambda:path/2015-03-31/functions/${fn.functionArn}/invocations`;
      openApiJson = openApiJson.replace(new RegExp(placeholder, 'g'), uri);
    }

    const api = new apigateway.SpecRestApi(this, 'AutoGeneratedRestApi', {
      apiDefinition: apigateway.ApiDefinition.fromInline(JSON.parse(openApiJson)),

      deployOptions: {
        stageName: props?.tags?.['Environment'] || 'dev'
      }
    });

    new cdk.CfnOutput(this, 'APIEndpoint', {
      value: `${api.url}hello`,
    });
  }
}
*/
/* //09/07/2025
// lib/api_gateway_cicd_demo-stack.ts
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';
import * as lambda from 'aws-cdk-lib/aws-lambda';
import * as apigateway from 'aws-cdk-lib/aws-apigateway';
import * as fs from 'fs';
import * as path from 'path';

export class ApiGatewayCicdDemoStacks extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    const lambdaPath = path.join(__dirname, '../lambda');
    const resourceMapPath = path.join(__dirname, '../resource-map.json');

    const resourceMap: Record<string, string> = JSON.parse(
      fs.readFileSync(resourceMapPath, 'utf8')
    );

    const lambdaFns: Record<string, lambda.Function> = {};

    for (const [placeholder, handler] of Object.entries(resourceMap)) {
      const logicalName = handler.replace(/[\/.\-]/g, '') + 'Fn';

      const fn = new lambda.Function(this, logicalName, {
        runtime: lambda.Runtime.NODEJS_18_X,
        handler: handler,
        code: lambda.Code.fromAsset(lambdaPath),
      });

      fn.grantInvoke(new cdk.aws_iam.ServicePrincipal('apigateway.amazonaws.com'));

      lambdaFns[placeholder] = fn;
    }

    let openApiJson = fs.readFileSync('api-definition.json', 'utf8');
    for (const [placeholder, fn] of Object.entries(lambdaFns)) {
      const uri = `arn:aws:apigateway:${this.region}:lambda:path/2015-03-31/functions/${fn.functionArn}/invocations`;
      openApiJson = openApiJson.replace(new RegExp(placeholder, 'g'), uri);
    }

    const envStage = props?.tags?.['Environment'] || 'dev';

    const api = new apigateway.SpecRestApi(this, `AutoGeneratedRestApi-${envStage}`, {
      apiDefinition: apigateway.ApiDefinition.fromInline(JSON.parse(openApiJson)),
      deployOptions: {
        stageName: envStage,
      },
    });

    new cdk.CfnOutput(this, 'APIEndpoint', {
      value: `${api.url}hello`,
    });
  }
}
*/
/*
// lib/api_gateway_cicd_demo-stack.ts
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';
import * as apigateway from 'aws-cdk-lib/aws-apigateway';
import * as fs from 'fs';
import * as path from 'path';

export class ApiGatewayCicdDemoStacks extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    const apiDefinitionPath = path.join(__dirname, '../api-definition.json');
    
    const openApiJson = JSON.parse(fs.readFileSync(apiDefinitionPath, 'utf8'));

    const envStage = props?.tags?.['Environment'] || 'dev';

    const api = new apigateway.SpecRestApi(this, `GlobalLoyaltyApi-${envStage}`, {
      apiDefinition: apigateway.ApiDefinition.fromInline(openApiJson),
      deployOptions: {
        stageName: envStage,
        variables: {
          pointsUrl: `loyalty-backend-${envStage}.internal`,  // customize as per your backend DNS
          usersUrl: `users-service-${envStage}.internal`       // customize as needed
        }
      },
    });

    new cdk.CfnOutput(this, 'ApiEndpoint', {
      value: api.url,
    });
  }
}
*/
/*
// lib/api_gateway_cicd_demo-stack.ts
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';
import * as apigateway from 'aws-cdk-lib/aws-apigateway';
import * as fs from 'fs';
import * as path from 'path';

export class ApiGatewayCicdDemoStacks extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    const envStage = props?.tags?.['Environment'] || 'dev';

    const apiDefinitionDir = path.join(__dirname, '../api-definition');
    const envSpecificPath = path.join(apiDefinitionDir, `${envStage}.json`);
    const fallbackPath = path.join(apiDefinitionDir, 'api.json');

    let openApiJson: any;

    if (fs.existsSync(envSpecificPath)) {
      openApiJson = JSON.parse(fs.readFileSync(envSpecificPath, 'utf8'));
      console.log(`✅ Loaded OpenAPI spec for '${envStage}'`);
    } else if (fs.existsSync(fallbackPath)) {
      openApiJson = JSON.parse(fs.readFileSync(fallbackPath, 'utf8'));
      console.warn(`⚠️  OpenAPI spec for '${envStage}' not found. Falling back to 'api.json'`);
    } else {
      throw new Error(`❌ No OpenAPI spec found for '${envStage}' and no fallback available.`);
    }

    const api = new apigateway.SpecRestApi(this, `GlobalLoyaltyApi-${envStage}`, {
      apiDefinition: apigateway.ApiDefinition.fromInline(openApiJson),
      deployOptions: {
        stageName: envStage,
        variables: {
          pointsUrl: `loyalty-backend-${envStage}.internal`,
          usersUrl: `users-service-${envStage}.internal`,
        },
      },
    });

    new cdk.CfnOutput(this, 'ApiEndpoint', {
      value: api.url,
    });
  }
}
*/
/*
// deploy api individually for each environment
// lib/api_gateway_cicd_demo-stack.ts
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';
import * as apigateway from 'aws-cdk-lib/aws-apigateway';
import * as fs from 'fs';
import * as path from 'path';

export class ApiGatewayCicdDemoStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    const envStages = ['dev', 'stage', 'prod'];
    const apiDefinitionDir = path.join(__dirname, '../api-definition');

    for (const envStage of envStages) {
      const envPath = path.join(apiDefinitionDir, `${envStage}.json`);
      if (!fs.existsSync(envPath)) {
        console.warn(`⚠️ Skipping '${envStage}' – File not found: ${envPath}`);
        continue;
      }

      const openApiSpec = JSON.parse(fs.readFileSync(envPath, 'utf8'));

      new apigateway.SpecRestApi(this, `SpecApi-${envStage}`, {
        apiDefinition: apigateway.ApiDefinition.fromAsset(envPath),
        restApiName: `GlobalLoyaltyApi-${envStage}`,
        deployOptions: {
          stageName: envStage,
          variables: {
            pointsUrl: `loyalty-backend-${envStage}.internal`,
            usersUrl: `users-service-${envStage}.internal`,
          },
        },
      });
    }
  }
}
*/
/*
// creating a same name API Gateway for each environment
// lib/api_gateway_cicd_demo-stack.ts
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';
import * as apigateway from 'aws-cdk-lib/aws-apigateway';
import * as fs from 'fs';
import * as path from 'path';

export class ApiGatewayCicdDemoStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    const envStage = this.node.tryGetContext('env');
    if (!envStage) {
      throw new Error("Missing context variable 'env'. Use --context env=dev|stage|prod");
    }

    const apiDefinitionDir = path.join(__dirname, '../api-definition');
    const envPath = path.join(apiDefinitionDir, `${envStage}.json`);
    if (!fs.existsSync(envPath)) {
      throw new Error(`❌ OpenAPI file for '${envStage}' not found: ${envPath}`);
    }

    const api = new apigateway.SpecRestApi(this, 'GlobalLoyaltyApi', {
      apiDefinition: apigateway.ApiDefinition.fromAsset(envPath),
      restApiName: 'GlobalLoyaltyApi',
      deployOptions: {
        stageName: envStage,
        variables: {
          pointsUrl: `loyalty-backend-${envStage}.internal`,
          usersUrl: `users-service-${envStage}.internal`,
        },
      },
    });
  }
}*/
/*
// Commented at 8:50pm on 15 july 2025
// lib/api_gateway_cicd_demo-stack.ts
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';
import * as apigateway from 'aws-cdk-lib/aws-apigateway';
import * as fs from 'fs';
import * as path from 'path';

export class ApiGatewayCicdDemoStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    const stage = this.node.tryGetContext('env');
    if (!stage) {
      throw new Error("❌ Missing context variable 'env'. Use --context env=<stage>");
    }

    const envPath = path.join(__dirname, `../api-definition/${stage}.json`);
    if (!fs.existsSync(envPath)) {
      throw new Error(`❌ OpenAPI file for stage '${stage}' not found at ${envPath}`);
    }

    const openApiSpec = JSON.parse(fs.readFileSync(envPath, 'utf8'));

    // Create single shared API Gateway
    const api = new apigateway.RestApi(this, 'GlobalLoyaltyApi', {
      restApiName: 'GlobalLoyaltyApi',
      description: 'Shared API Gateway for all stages',
      deploy: false, // disable auto-deploy, we will manage it manually
    });

    // Add dummy method to avoid validation error
    api.root.addMethod('GET', new apigateway.MockIntegration({
      integrationResponses: [{ statusCode: "200" }],
      requestTemplates: { "application/json": '{"statusCode": 200}' },
    }), {
      methodResponses: [{ statusCode: "200" }],
    });

    // Deployment & stage specific configuration
    const deployment = new apigateway.Deployment(this, `Deployment-${stage}`, {
      api,
    });

    new apigateway.Stage(this, `Stage-${stage}`, {
      deployment,
      stageName: stage,
      variables: {
        pointsUrl: `loyalty-backend-${stage}.internal`,
        usersUrl: `users-service-${stage}.internal`,
      },
    });
  }
}*/
/*
// lib/api_gateway_cicd_demo-stack.ts
import * as cdk from 'aws-cdk-lib';
import { Construct } from 'constructs';
import * as apigateway from 'aws-cdk-lib/aws-apigateway';
import * as fs from 'fs';
import * as path from 'path';

export class ApiGatewayCicdDemoStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    const envStages = ['dev', 'stage', 'prod'];
    const apiDefinitionDir = path.join(__dirname, '../api-definition');

    // Dummy deployment and stage to satisfy CDK requirement
    const dummyDeployment = new apigateway.Deployment(this, 'DummyDeployment', {
      api: undefined as any // placeholder, will not be used since deploy: false
    });
    const dummyStage = new apigateway.Stage(this, 'DummyStage', {
      deployment: dummyDeployment,
      stageName: 'placeholder',
    });

    // Base API with dummy stage
    const baseApi = new apigateway.RestApi(this, 'GlobalLoyaltyApi', {
      restApiName: 'Global-Loyalty-MultiStage',
      description: 'Global Loyalty API with Multi-Stage OpenAPI Specs',
      deploy: false,
    });

    for (const envStage of envStages) {
      const envPath = path.join(apiDefinitionDir, `${envStage}.json`);
      if (!fs.existsSync(envPath)) {
        console.warn(`⚠️ Skipping '${envStage}' – File not found: ${envPath}`);
        continue;
      }

      const openApiSpec = JSON.parse(fs.readFileSync(envPath, 'utf8'));

      const specApi = new apigateway.SpecRestApi(this, `SpecApi-${envStage}`, {
        apiDefinition: apigateway.ApiDefinition.fromInline(openApiSpec),
        deploy: false,
      });

      const deployment = new apigateway.Deployment(this, `Deployment-${envStage}`, {
        api: baseApi,
      });

      new apigateway.Stage(this, `Stage-${envStage}`, {
        deployment,
        stageName: envStage,
        variables: {
          pointsUrl: `loyalty-backend-${envStage}.internal`,
          usersUrl: `users-service-${envStage}.internal`,
        },
      });
    }

    new cdk.CfnOutput(this, 'BaseApiId', {
      value: baseApi.restApiId,
    });
  }
}*/
/////////////////////////////
/*
import { Stack, StackProps, aws_apigateway as apigw } from 'aws-cdk-lib';
import { Construct } from 'constructs';
import * as path from 'path';

export class ApiGatewayCicdDemoStack extends Stack {
  constructor(scope: Construct, id: string, props?: StackProps, envName?: string) {
    super(scope, id, props);

    if (!envName) throw new Error("Missing environment name");

    const specPath = path.join(__dirname, '..', 'api-definition', `${envName}.json`);

    new apigw.SpecRestApi(this, `ApiGw-${envName}`, {
      apiDefinition: apigw.ApiDefinition.fromAsset(specPath),
      deployOptions: {
        stageName: envName,
        variables: {
          pointsUrl: `https://${envName}.api.skechers.com`, // override if needed
          contentfulUrl: `https://${envName}.api.skechers.com`,
          usersUrl: `https://${envName}.api.skechers.com`
        }
      },
      restApiName: `LoyaltyApi-${envName}`,
      description: `API Gateway for ${envName} environment`,
    });
  }
}
*/
const aws_cdk_lib_1 = require("aws-cdk-lib");
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
class ApiGatewayCicdDemoStack extends aws_cdk_lib_1.Stack {
    constructor(scope, id, props) {
        super(scope, id, props);
        const api_definition = {
            dev: 'dev.json',
            stage: 'stage.json',
            prod: 'prod.json'
        };
        const restApi = new aws_cdk_lib_1.aws_apigateway.CfnRestApi(this, 'LoyaltyRestApi', {
            name: 'LoyaltyApiGateway',
            description: 'Single API Gateway with multiple OpenAPI-based stages',
            failOnWarnings: true,
            endpointConfiguration: {
                types: ['REGIONAL']
            },
            body: JSON.parse(fs.readFileSync(path.join(__dirname, '..', 'api_definition', api_definition.dev), 'utf8')) // any one to initialize
        });
        for (const [env, filename] of Object.entries(api_definition)) {
            const specBody = JSON.parse(fs.readFileSync(path.join(__dirname, '..', 'api_definition', filename), 'utf8'));
            const deployment = new aws_cdk_lib_1.aws_apigateway.CfnDeployment(this, `Deployment-${env}`, {
                restApiId: restApi.ref,
                description: `${env} deployment`
            });
            new aws_cdk_lib_1.aws_apigateway.CfnStage(this, `Stage-${env}`, {
                restApiId: restApi.ref,
                deploymentId: deployment.ref,
                stageName: env,
                variables: {
                    pointsUrl: `${env}.api.skechers.com`,
                    contentfulUrl: `${env}.api.skechers.com`,
                    usersUrl: `${env}.api.skechers.com`
                }
            });
            new aws_cdk_lib_1.CfnOutput(this, `Url-${env}`, {
                value: `https://${restApi.ref}.execute-api.${this.region}.amazonaws.com/${env}`
            });
        }
    }
}
exports.ApiGatewayCicdDemoStack = ApiGatewayCicdDemoStack;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBpX2dhdGV3YXlfY2ljZF9kZW1vLXN0YWNrLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vbGliL2FwaV9nYXRld2F5X2NpY2RfZGVtby1zdGFjay50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUE4Q0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBd0RFO0FBRUY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBd0RFO0FBRUY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFrQ0U7QUFFRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQThDRTtBQUVGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUF1Q0U7QUFFRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBb0NHO0FBR0g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXNERztBQUdIOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0ErREc7QUFNSCw2QkFBNkI7QUFFN0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUE0QkU7QUFFRiw2Q0FBb0Y7QUFFcEYsdUNBQXlCO0FBQ3pCLDJDQUE2QjtBQUU3QixNQUFhLHVCQUF3QixTQUFRLG1CQUFLO0lBQ2hELFlBQVksS0FBZ0IsRUFBRSxFQUFVLEVBQUUsS0FBa0I7UUFDMUQsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFFeEIsTUFBTSxjQUFjLEdBQUc7WUFDckIsR0FBRyxFQUFFLFVBQVU7WUFDZixLQUFLLEVBQUUsWUFBWTtZQUNuQixJQUFJLEVBQUUsV0FBVztTQUNsQixDQUFDO1FBRUYsTUFBTSxPQUFPLEdBQUcsSUFBSSw0QkFBSyxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsZ0JBQWdCLEVBQUU7WUFDM0QsSUFBSSxFQUFFLG1CQUFtQjtZQUN6QixXQUFXLEVBQUUsdURBQXVEO1lBQ3BFLGNBQWMsRUFBRSxJQUFJO1lBQ3BCLHFCQUFxQixFQUFFO2dCQUNyQixLQUFLLEVBQUUsQ0FBQyxVQUFVLENBQUM7YUFDcEI7WUFDRCxJQUFJLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksRUFBRSxnQkFBZ0IsRUFBRSxjQUFjLENBQUMsR0FBRyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyx3QkFBd0I7U0FDckksQ0FBQyxDQUFDO1FBRUgsS0FBSyxNQUFNLENBQUMsR0FBRyxFQUFFLFFBQVEsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLEVBQUUsQ0FBQztZQUM3RCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxFQUFFLGdCQUFnQixFQUFFLFFBQVEsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUM7WUFFN0csTUFBTSxVQUFVLEdBQUcsSUFBSSw0QkFBSyxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsY0FBYyxHQUFHLEVBQUUsRUFBRTtnQkFDcEUsU0FBUyxFQUFFLE9BQU8sQ0FBQyxHQUFHO2dCQUN0QixXQUFXLEVBQUUsR0FBRyxHQUFHLGFBQWE7YUFDakMsQ0FBQyxDQUFDO1lBRUgsSUFBSSw0QkFBSyxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsU0FBUyxHQUFHLEVBQUUsRUFBRTtnQkFDdkMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxHQUFHO2dCQUN0QixZQUFZLEVBQUUsVUFBVSxDQUFDLEdBQUc7Z0JBQzVCLFNBQVMsRUFBRSxHQUFHO2dCQUNkLFNBQVMsRUFBRTtvQkFDVCxTQUFTLEVBQUUsR0FBRyxHQUFHLG1CQUFtQjtvQkFDcEMsYUFBYSxFQUFFLEdBQUcsR0FBRyxtQkFBbUI7b0JBQ3hDLFFBQVEsRUFBRSxHQUFHLEdBQUcsbUJBQW1CO2lCQUNwQzthQUNGLENBQUMsQ0FBQztZQUVILElBQUksdUJBQVMsQ0FBQyxJQUFJLEVBQUUsT0FBTyxHQUFHLEVBQUUsRUFBRTtnQkFDaEMsS0FBSyxFQUFFLFdBQVcsT0FBTyxDQUFDLEdBQUcsZ0JBQWdCLElBQUksQ0FBQyxNQUFNLGtCQUFrQixHQUFHLEVBQUU7YUFDaEYsQ0FBQyxDQUFDO1FBQ0wsQ0FBQztJQUNILENBQUM7Q0FDRjtBQTVDRCwwREE0Q0MiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG5pbXBvcnQgKiBhcyBjZGsgZnJvbSAnYXdzLWNkay1saWInO1xyXG5pbXBvcnQgeyBDb25zdHJ1Y3QgfSBmcm9tICdjb25zdHJ1Y3RzJztcclxuaW1wb3J0ICogYXMgbGFtYmRhIGZyb20gJ2F3cy1jZGstbGliL2F3cy1sYW1iZGEnO1xyXG5pbXBvcnQgKiBhcyBhcGlnYXRld2F5IGZyb20gJ2F3cy1jZGstbGliL2F3cy1hcGlnYXRld2F5JztcclxuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcclxuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xyXG5cclxuZXhwb3J0IGNsYXNzIEFwaUdhdGV3YXlDaWNkRGVtb1N0YWNrIGV4dGVuZHMgY2RrLlN0YWNrIHtcclxuICBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wcz86IGNkay5TdGFja1Byb3BzKSB7XHJcbiAgICBzdXBlcihzY29wZSwgaWQsIHByb3BzKTtcclxuXHJcbiAgICBjb25zdCBoZWxsb0ZuID0gbmV3IGxhbWJkYS5GdW5jdGlvbih0aGlzLCAnSGVsbG9GdW5jdGlvbicsIHtcclxuICAgICAgcnVudGltZTogbGFtYmRhLlJ1bnRpbWUuTk9ERUpTXzE4X1gsICAvLyA8LSBGaXggaGVyZVxyXG4gICAgICBoYW5kbGVyOiAnaGVsbG8uaGFuZGxlcicsXHJcbiAgICAgIGNvZGU6IGxhbWJkYS5Db2RlLmZyb21Bc3NldChwYXRoLmpvaW4oX19kaXJuYW1lLCAnLi4vbGFtYmRhJykpLFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgdXNlckZuID0gbmV3IGxhbWJkYS5GdW5jdGlvbih0aGlzLCAnVXNlckZ1bmN0aW9uJywge1xyXG4gICAgICBydW50aW1lOiBsYW1iZGEuUnVudGltZS5OT0RFSlNfMThfWCxcclxuICAgICAgaGFuZGxlcjogJ3VzZXIuaGFuZGxlcicsXHJcbiAgICAgIGNvZGU6IGxhbWJkYS5Db2RlLmZyb21Bc3NldChwYXRoLmpvaW4oX19kaXJuYW1lLCAnLi4vbGFtYmRhJykpLFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gTG9hZCBhbmQgaW5qZWN0IEFSTnMgaW50byBPcGVuQVBJIHNwZWNcclxuICAgIGNvbnN0IHJhd1NwZWMgPSBmcy5yZWFkRmlsZVN5bmMoJ2FwaS1kZWZpbml0aW9uLmpzb24nLCAndXRmOCcpO1xyXG4gICAgY29uc3Qgc3BlYyA9IHJhd1NwZWNcclxuICAgICAgLnJlcGxhY2UoJ1JFUExBQ0VfSEVMTE9fVVJJJywgYGFybjphd3M6YXBpZ2F0ZXdheToke3RoaXMucmVnaW9ufTpsYW1iZGE6cGF0aC8yMDE1LTAzLTMxL2Z1bmN0aW9ucy8ke2hlbGxvRm4uZnVuY3Rpb25Bcm59L2ludm9jYXRpb25zYClcclxuICAgICAgLnJlcGxhY2UoJ1JFUExBQ0VfVVNFUl9VUkknLCBgYXJuOmF3czphcGlnYXRld2F5OiR7dGhpcy5yZWdpb259OmxhbWJkYTpwYXRoLzIwMTUtMDMtMzEvZnVuY3Rpb25zLyR7dXNlckZuLmZ1bmN0aW9uQXJufS9pbnZvY2F0aW9uc2ApO1xyXG4gICAgY29uc3Qgb3BlbkFwaVNwZWMgPSBKU09OLnBhcnNlKHNwZWMpO1xyXG5cclxuICAgIGNvbnN0IHJlc3RBcGkgPSBuZXcgYXBpZ2F0ZXdheS5TcGVjUmVzdEFwaSh0aGlzLCAnUmVzdEFwaUZyb21Kc29uJywge1xyXG4gICAgICBhcGlEZWZpbml0aW9uOiBhcGlnYXRld2F5LkFwaURlZmluaXRpb24uZnJvbUlubGluZShvcGVuQXBpU3BlYyksXHJcbiAgICAgIGRlcGxveU9wdGlvbnM6IHtcclxuICAgICAgICBzdGFnZU5hbWU6ICdkZXYnLFxyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgaGVsbG9Gbi5ncmFudEludm9rZShuZXcgY2RrLmF3c19pYW0uU2VydmljZVByaW5jaXBhbCgnYXBpZ2F0ZXdheS5hbWF6b25hd3MuY29tJykpO1xyXG4gICAgdXNlckZuLmdyYW50SW52b2tlKG5ldyBjZGsuYXdzX2lhbS5TZXJ2aWNlUHJpbmNpcGFsKCdhcGlnYXRld2F5LmFtYXpvbmF3cy5jb20nKSk7XHJcblxyXG4gICAgbmV3IGNkay5DZm5PdXRwdXQodGhpcywgJ0FQSUVuZHBvaW50Jywge1xyXG4gICAgICB2YWx1ZTogYCR7cmVzdEFwaS51cmx9aGVsbG9gLFxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcbiovXHJcblxyXG4vKlxyXG5pbXBvcnQgKiBhcyBjZGsgZnJvbSAnYXdzLWNkay1saWInO1xyXG5pbXBvcnQgeyBDb25zdHJ1Y3QgfSBmcm9tICdjb25zdHJ1Y3RzJztcclxuaW1wb3J0ICogYXMgbGFtYmRhIGZyb20gJ2F3cy1jZGstbGliL2F3cy1sYW1iZGEnO1xyXG5pbXBvcnQgKiBhcyBhcGlnYXRld2F5IGZyb20gJ2F3cy1jZGstbGliL2F3cy1hcGlnYXRld2F5JztcclxuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xyXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xyXG5cclxuZXhwb3J0IGNsYXNzIEFwaUdhdGV3YXlDaWNkRGVtb1N0YWNrIGV4dGVuZHMgY2RrLlN0YWNrIHtcclxuICBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wcz86IGNkay5TdGFja1Byb3BzKSB7XHJcbiAgICBzdXBlcihzY29wZSwgaWQsIHByb3BzKTtcclxuXHJcbiAgICBjb25zdCBsYW1iZGFQYXRoID0gcGF0aC5qb2luKF9fZGlybmFtZSwgJy4uL2xhbWJkYScpO1xyXG5cclxuICAgIGNvbnN0IHJlc291cmNlTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0gSlNPTi5wYXJzZShcclxuICAgICAgZnMucmVhZEZpbGVTeW5jKCdyZXNvdXJjZS1tYXAuanNvbicsICd1dGY4JylcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgbGFtYmRhRm5zOiBSZWNvcmQ8c3RyaW5nLCBsYW1iZGEuRnVuY3Rpb24+ID0ge307XHJcblxyXG4gICAgLy8gU3RlcCAxOiBDcmVhdGUgTGFtYmRhIGZ1bmN0aW9ucyBkeW5hbWljYWxseVxyXG4gICAgZm9yIChjb25zdCBbcGxhY2Vob2xkZXIsIGhhbmRsZXJdIG9mIE9iamVjdC5lbnRyaWVzKHJlc291cmNlTWFwKSkge1xyXG4gICAgICBjb25zdCBsb2dpY2FsTmFtZSA9IGhhbmRsZXIucmVwbGFjZSgvW15cXHddL2csICcnKSArICdGbic7XHJcblxyXG4gICAgICBsYW1iZGFGbnNbcGxhY2Vob2xkZXJdID0gbmV3IGxhbWJkYS5GdW5jdGlvbih0aGlzLCBsb2dpY2FsTmFtZSwge1xyXG4gICAgICAgIHJ1bnRpbWU6IGxhbWJkYS5SdW50aW1lLk5PREVKU18xOF9YLFxyXG4gICAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXHJcbiAgICAgICAgY29kZTogbGFtYmRhLkNvZGUuZnJvbUFzc2V0KGxhbWJkYVBhdGgpLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGxhbWJkYUZuc1twbGFjZWhvbGRlcl0uZ3JhbnRJbnZva2UoXHJcbiAgICAgICAgbmV3IGNkay5hd3NfaWFtLlNlcnZpY2VQcmluY2lwYWwoJ2FwaWdhdGV3YXkuYW1hem9uYXdzLmNvbScpXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU3RlcCAyOiBSZWFkIE9wZW5BUEkgSlNPTiBhbmQgaW5qZWN0IExhbWJkYSBBUk5zXHJcbiAgICBsZXQgb3BlbkFwaUpzb24gPSBmcy5yZWFkRmlsZVN5bmMoJ2FwaS1kZWZpbml0aW9uLmpzb24nLCAndXRmOCcpO1xyXG5cclxuICAgIGZvciAoY29uc3QgW3BsYWNlaG9sZGVyLCBmbl0gb2YgT2JqZWN0LmVudHJpZXMobGFtYmRhRm5zKSkge1xyXG4gICAgICBjb25zdCB1cmkgPSBgYXJuOmF3czphcGlnYXRld2F5OiR7dGhpcy5yZWdpb259OmxhbWJkYTpwYXRoLzIwMTUtMDMtMzEvZnVuY3Rpb25zLyR7Zm4uZnVuY3Rpb25Bcm59L2ludm9jYXRpb25zYDtcclxuICAgICAgb3BlbkFwaUpzb24gPSBvcGVuQXBpSnNvbi5yZXBsYWNlKG5ldyBSZWdFeHAocGxhY2Vob2xkZXIsICdnJyksIHVyaSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYXBpID0gbmV3IGFwaWdhdGV3YXkuU3BlY1Jlc3RBcGkodGhpcywgJ0F1dG9HZW5lcmF0ZWRSZXN0QXBpJywge1xyXG4gICAgICBhcGlEZWZpbml0aW9uOiBhcGlnYXRld2F5LkFwaURlZmluaXRpb24uZnJvbUlubGluZShKU09OLnBhcnNlKG9wZW5BcGlKc29uKSksXHJcblxyXG4gICAgICBkZXBsb3lPcHRpb25zOiB7XHJcbiAgICAgICAgc3RhZ2VOYW1lOiBwcm9wcz8udGFncz8uWydFbnZpcm9ubWVudCddIHx8ICdkZXYnXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIG5ldyBjZGsuQ2ZuT3V0cHV0KHRoaXMsICdBUElFbmRwb2ludCcsIHtcclxuICAgICAgdmFsdWU6IGAke2FwaS51cmx9aGVsbG9gLFxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcbiovXHJcblxyXG4vKiAvLzA5LzA3LzIwMjVcclxuLy8gbGliL2FwaV9nYXRld2F5X2NpY2RfZGVtby1zdGFjay50c1xyXG5pbXBvcnQgKiBhcyBjZGsgZnJvbSAnYXdzLWNkay1saWInO1xyXG5pbXBvcnQgeyBDb25zdHJ1Y3QgfSBmcm9tICdjb25zdHJ1Y3RzJztcclxuaW1wb3J0ICogYXMgbGFtYmRhIGZyb20gJ2F3cy1jZGstbGliL2F3cy1sYW1iZGEnO1xyXG5pbXBvcnQgKiBhcyBhcGlnYXRld2F5IGZyb20gJ2F3cy1jZGstbGliL2F3cy1hcGlnYXRld2F5JztcclxuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xyXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xyXG5cclxuZXhwb3J0IGNsYXNzIEFwaUdhdGV3YXlDaWNkRGVtb1N0YWNrcyBleHRlbmRzIGNkay5TdGFjayB7XHJcbiAgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM/OiBjZGsuU3RhY2tQcm9wcykge1xyXG4gICAgc3VwZXIoc2NvcGUsIGlkLCBwcm9wcyk7XHJcblxyXG4gICAgY29uc3QgbGFtYmRhUGF0aCA9IHBhdGguam9pbihfX2Rpcm5hbWUsICcuLi9sYW1iZGEnKTtcclxuICAgIGNvbnN0IHJlc291cmNlTWFwUGF0aCA9IHBhdGguam9pbihfX2Rpcm5hbWUsICcuLi9yZXNvdXJjZS1tYXAuanNvbicpO1xyXG5cclxuICAgIGNvbnN0IHJlc291cmNlTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0gSlNPTi5wYXJzZShcclxuICAgICAgZnMucmVhZEZpbGVTeW5jKHJlc291cmNlTWFwUGF0aCwgJ3V0ZjgnKVxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBsYW1iZGFGbnM6IFJlY29yZDxzdHJpbmcsIGxhbWJkYS5GdW5jdGlvbj4gPSB7fTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IFtwbGFjZWhvbGRlciwgaGFuZGxlcl0gb2YgT2JqZWN0LmVudHJpZXMocmVzb3VyY2VNYXApKSB7XHJcbiAgICAgIGNvbnN0IGxvZ2ljYWxOYW1lID0gaGFuZGxlci5yZXBsYWNlKC9bXFwvLlxcLV0vZywgJycpICsgJ0ZuJztcclxuXHJcbiAgICAgIGNvbnN0IGZuID0gbmV3IGxhbWJkYS5GdW5jdGlvbih0aGlzLCBsb2dpY2FsTmFtZSwge1xyXG4gICAgICAgIHJ1bnRpbWU6IGxhbWJkYS5SdW50aW1lLk5PREVKU18xOF9YLFxyXG4gICAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXHJcbiAgICAgICAgY29kZTogbGFtYmRhLkNvZGUuZnJvbUFzc2V0KGxhbWJkYVBhdGgpLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGZuLmdyYW50SW52b2tlKG5ldyBjZGsuYXdzX2lhbS5TZXJ2aWNlUHJpbmNpcGFsKCdhcGlnYXRld2F5LmFtYXpvbmF3cy5jb20nKSk7XHJcblxyXG4gICAgICBsYW1iZGFGbnNbcGxhY2Vob2xkZXJdID0gZm47XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IG9wZW5BcGlKc29uID0gZnMucmVhZEZpbGVTeW5jKCdhcGktZGVmaW5pdGlvbi5qc29uJywgJ3V0ZjgnKTtcclxuICAgIGZvciAoY29uc3QgW3BsYWNlaG9sZGVyLCBmbl0gb2YgT2JqZWN0LmVudHJpZXMobGFtYmRhRm5zKSkge1xyXG4gICAgICBjb25zdCB1cmkgPSBgYXJuOmF3czphcGlnYXRld2F5OiR7dGhpcy5yZWdpb259OmxhbWJkYTpwYXRoLzIwMTUtMDMtMzEvZnVuY3Rpb25zLyR7Zm4uZnVuY3Rpb25Bcm59L2ludm9jYXRpb25zYDtcclxuICAgICAgb3BlbkFwaUpzb24gPSBvcGVuQXBpSnNvbi5yZXBsYWNlKG5ldyBSZWdFeHAocGxhY2Vob2xkZXIsICdnJyksIHVyaSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZW52U3RhZ2UgPSBwcm9wcz8udGFncz8uWydFbnZpcm9ubWVudCddIHx8ICdkZXYnO1xyXG5cclxuICAgIGNvbnN0IGFwaSA9IG5ldyBhcGlnYXRld2F5LlNwZWNSZXN0QXBpKHRoaXMsIGBBdXRvR2VuZXJhdGVkUmVzdEFwaS0ke2VudlN0YWdlfWAsIHtcclxuICAgICAgYXBpRGVmaW5pdGlvbjogYXBpZ2F0ZXdheS5BcGlEZWZpbml0aW9uLmZyb21JbmxpbmUoSlNPTi5wYXJzZShvcGVuQXBpSnNvbikpLFxyXG4gICAgICBkZXBsb3lPcHRpb25zOiB7XHJcbiAgICAgICAgc3RhZ2VOYW1lOiBlbnZTdGFnZSxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIG5ldyBjZGsuQ2ZuT3V0cHV0KHRoaXMsICdBUElFbmRwb2ludCcsIHtcclxuICAgICAgdmFsdWU6IGAke2FwaS51cmx9aGVsbG9gLFxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcbiovXHJcblxyXG4vKlxyXG4vLyBsaWIvYXBpX2dhdGV3YXlfY2ljZF9kZW1vLXN0YWNrLnRzXHJcbmltcG9ydCAqIGFzIGNkayBmcm9tICdhd3MtY2RrLWxpYic7XHJcbmltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gJ2NvbnN0cnVjdHMnO1xyXG5pbXBvcnQgKiBhcyBhcGlnYXRld2F5IGZyb20gJ2F3cy1jZGstbGliL2F3cy1hcGlnYXRld2F5JztcclxuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xyXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xyXG5cclxuZXhwb3J0IGNsYXNzIEFwaUdhdGV3YXlDaWNkRGVtb1N0YWNrcyBleHRlbmRzIGNkay5TdGFjayB7XHJcbiAgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM/OiBjZGsuU3RhY2tQcm9wcykge1xyXG4gICAgc3VwZXIoc2NvcGUsIGlkLCBwcm9wcyk7XHJcblxyXG4gICAgY29uc3QgYXBpRGVmaW5pdGlvblBhdGggPSBwYXRoLmpvaW4oX19kaXJuYW1lLCAnLi4vYXBpLWRlZmluaXRpb24uanNvbicpO1xyXG4gICAgXHJcbiAgICBjb25zdCBvcGVuQXBpSnNvbiA9IEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKGFwaURlZmluaXRpb25QYXRoLCAndXRmOCcpKTtcclxuXHJcbiAgICBjb25zdCBlbnZTdGFnZSA9IHByb3BzPy50YWdzPy5bJ0Vudmlyb25tZW50J10gfHwgJ2Rldic7XHJcblxyXG4gICAgY29uc3QgYXBpID0gbmV3IGFwaWdhdGV3YXkuU3BlY1Jlc3RBcGkodGhpcywgYEdsb2JhbExveWFsdHlBcGktJHtlbnZTdGFnZX1gLCB7XHJcbiAgICAgIGFwaURlZmluaXRpb246IGFwaWdhdGV3YXkuQXBpRGVmaW5pdGlvbi5mcm9tSW5saW5lKG9wZW5BcGlKc29uKSxcclxuICAgICAgZGVwbG95T3B0aW9uczoge1xyXG4gICAgICAgIHN0YWdlTmFtZTogZW52U3RhZ2UsXHJcbiAgICAgICAgdmFyaWFibGVzOiB7XHJcbiAgICAgICAgICBwb2ludHNVcmw6IGBsb3lhbHR5LWJhY2tlbmQtJHtlbnZTdGFnZX0uaW50ZXJuYWxgLCAgLy8gY3VzdG9taXplIGFzIHBlciB5b3VyIGJhY2tlbmQgRE5TXHJcbiAgICAgICAgICB1c2Vyc1VybDogYHVzZXJzLXNlcnZpY2UtJHtlbnZTdGFnZX0uaW50ZXJuYWxgICAgICAgIC8vIGN1c3RvbWl6ZSBhcyBuZWVkZWRcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICBuZXcgY2RrLkNmbk91dHB1dCh0aGlzLCAnQXBpRW5kcG9pbnQnLCB7XHJcbiAgICAgIHZhbHVlOiBhcGkudXJsLFxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcbiovXHJcblxyXG4vKlxyXG4vLyBsaWIvYXBpX2dhdGV3YXlfY2ljZF9kZW1vLXN0YWNrLnRzXHJcbmltcG9ydCAqIGFzIGNkayBmcm9tICdhd3MtY2RrLWxpYic7XHJcbmltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gJ2NvbnN0cnVjdHMnO1xyXG5pbXBvcnQgKiBhcyBhcGlnYXRld2F5IGZyb20gJ2F3cy1jZGstbGliL2F3cy1hcGlnYXRld2F5JztcclxuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xyXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xyXG5cclxuZXhwb3J0IGNsYXNzIEFwaUdhdGV3YXlDaWNkRGVtb1N0YWNrcyBleHRlbmRzIGNkay5TdGFjayB7XHJcbiAgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM/OiBjZGsuU3RhY2tQcm9wcykge1xyXG4gICAgc3VwZXIoc2NvcGUsIGlkLCBwcm9wcyk7XHJcblxyXG4gICAgY29uc3QgZW52U3RhZ2UgPSBwcm9wcz8udGFncz8uWydFbnZpcm9ubWVudCddIHx8ICdkZXYnO1xyXG5cclxuICAgIGNvbnN0IGFwaURlZmluaXRpb25EaXIgPSBwYXRoLmpvaW4oX19kaXJuYW1lLCAnLi4vYXBpLWRlZmluaXRpb24nKTtcclxuICAgIGNvbnN0IGVudlNwZWNpZmljUGF0aCA9IHBhdGguam9pbihhcGlEZWZpbml0aW9uRGlyLCBgJHtlbnZTdGFnZX0uanNvbmApO1xyXG4gICAgY29uc3QgZmFsbGJhY2tQYXRoID0gcGF0aC5qb2luKGFwaURlZmluaXRpb25EaXIsICdhcGkuanNvbicpO1xyXG5cclxuICAgIGxldCBvcGVuQXBpSnNvbjogYW55O1xyXG5cclxuICAgIGlmIChmcy5leGlzdHNTeW5jKGVudlNwZWNpZmljUGF0aCkpIHtcclxuICAgICAgb3BlbkFwaUpzb24gPSBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYyhlbnZTcGVjaWZpY1BhdGgsICd1dGY4JykpO1xyXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIExvYWRlZCBPcGVuQVBJIHNwZWMgZm9yICcke2VudlN0YWdlfSdgKTtcclxuICAgIH0gZWxzZSBpZiAoZnMuZXhpc3RzU3luYyhmYWxsYmFja1BhdGgpKSB7XHJcbiAgICAgIG9wZW5BcGlKc29uID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMoZmFsbGJhY2tQYXRoLCAndXRmOCcpKTtcclxuICAgICAgY29uc29sZS53YXJuKGDimqDvuI8gIE9wZW5BUEkgc3BlYyBmb3IgJyR7ZW52U3RhZ2V9JyBub3QgZm91bmQuIEZhbGxpbmcgYmFjayB0byAnYXBpLmpzb24nYCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYOKdjCBObyBPcGVuQVBJIHNwZWMgZm91bmQgZm9yICcke2VudlN0YWdlfScgYW5kIG5vIGZhbGxiYWNrIGF2YWlsYWJsZS5gKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhcGkgPSBuZXcgYXBpZ2F0ZXdheS5TcGVjUmVzdEFwaSh0aGlzLCBgR2xvYmFsTG95YWx0eUFwaS0ke2VudlN0YWdlfWAsIHtcclxuICAgICAgYXBpRGVmaW5pdGlvbjogYXBpZ2F0ZXdheS5BcGlEZWZpbml0aW9uLmZyb21JbmxpbmUob3BlbkFwaUpzb24pLFxyXG4gICAgICBkZXBsb3lPcHRpb25zOiB7XHJcbiAgICAgICAgc3RhZ2VOYW1lOiBlbnZTdGFnZSxcclxuICAgICAgICB2YXJpYWJsZXM6IHtcclxuICAgICAgICAgIHBvaW50c1VybDogYGxveWFsdHktYmFja2VuZC0ke2VudlN0YWdlfS5pbnRlcm5hbGAsXHJcbiAgICAgICAgICB1c2Vyc1VybDogYHVzZXJzLXNlcnZpY2UtJHtlbnZTdGFnZX0uaW50ZXJuYWxgLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICBuZXcgY2RrLkNmbk91dHB1dCh0aGlzLCAnQXBpRW5kcG9pbnQnLCB7XHJcbiAgICAgIHZhbHVlOiBhcGkudXJsLFxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcbiovXHJcblxyXG4vKlxyXG4vLyBkZXBsb3kgYXBpIGluZGl2aWR1YWxseSBmb3IgZWFjaCBlbnZpcm9ubWVudFxyXG4vLyBsaWIvYXBpX2dhdGV3YXlfY2ljZF9kZW1vLXN0YWNrLnRzXHJcbmltcG9ydCAqIGFzIGNkayBmcm9tICdhd3MtY2RrLWxpYic7XHJcbmltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gJ2NvbnN0cnVjdHMnO1xyXG5pbXBvcnQgKiBhcyBhcGlnYXRld2F5IGZyb20gJ2F3cy1jZGstbGliL2F3cy1hcGlnYXRld2F5JztcclxuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xyXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xyXG5cclxuZXhwb3J0IGNsYXNzIEFwaUdhdGV3YXlDaWNkRGVtb1N0YWNrIGV4dGVuZHMgY2RrLlN0YWNrIHtcclxuICBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wcz86IGNkay5TdGFja1Byb3BzKSB7XHJcbiAgICBzdXBlcihzY29wZSwgaWQsIHByb3BzKTtcclxuXHJcbiAgICBjb25zdCBlbnZTdGFnZXMgPSBbJ2RldicsICdzdGFnZScsICdwcm9kJ107XHJcbiAgICBjb25zdCBhcGlEZWZpbml0aW9uRGlyID0gcGF0aC5qb2luKF9fZGlybmFtZSwgJy4uL2FwaS1kZWZpbml0aW9uJyk7XHJcblxyXG4gICAgZm9yIChjb25zdCBlbnZTdGFnZSBvZiBlbnZTdGFnZXMpIHtcclxuICAgICAgY29uc3QgZW52UGF0aCA9IHBhdGguam9pbihhcGlEZWZpbml0aW9uRGlyLCBgJHtlbnZTdGFnZX0uanNvbmApO1xyXG4gICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZW52UGF0aCkpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oYOKaoO+4jyBTa2lwcGluZyAnJHtlbnZTdGFnZX0nIOKAkyBGaWxlIG5vdCBmb3VuZDogJHtlbnZQYXRofWApO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBvcGVuQXBpU3BlYyA9IEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKGVudlBhdGgsICd1dGY4JykpO1xyXG5cclxuICAgICAgbmV3IGFwaWdhdGV3YXkuU3BlY1Jlc3RBcGkodGhpcywgYFNwZWNBcGktJHtlbnZTdGFnZX1gLCB7XHJcbiAgICAgICAgYXBpRGVmaW5pdGlvbjogYXBpZ2F0ZXdheS5BcGlEZWZpbml0aW9uLmZyb21Bc3NldChlbnZQYXRoKSxcclxuICAgICAgICByZXN0QXBpTmFtZTogYEdsb2JhbExveWFsdHlBcGktJHtlbnZTdGFnZX1gLFxyXG4gICAgICAgIGRlcGxveU9wdGlvbnM6IHtcclxuICAgICAgICAgIHN0YWdlTmFtZTogZW52U3RhZ2UsXHJcbiAgICAgICAgICB2YXJpYWJsZXM6IHtcclxuICAgICAgICAgICAgcG9pbnRzVXJsOiBgbG95YWx0eS1iYWNrZW5kLSR7ZW52U3RhZ2V9LmludGVybmFsYCxcclxuICAgICAgICAgICAgdXNlcnNVcmw6IGB1c2Vycy1zZXJ2aWNlLSR7ZW52U3RhZ2V9LmludGVybmFsYCxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiovXHJcblxyXG4vKlxyXG4vLyBjcmVhdGluZyBhIHNhbWUgbmFtZSBBUEkgR2F0ZXdheSBmb3IgZWFjaCBlbnZpcm9ubWVudFxyXG4vLyBsaWIvYXBpX2dhdGV3YXlfY2ljZF9kZW1vLXN0YWNrLnRzXHJcbmltcG9ydCAqIGFzIGNkayBmcm9tICdhd3MtY2RrLWxpYic7XHJcbmltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gJ2NvbnN0cnVjdHMnO1xyXG5pbXBvcnQgKiBhcyBhcGlnYXRld2F5IGZyb20gJ2F3cy1jZGstbGliL2F3cy1hcGlnYXRld2F5JztcclxuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xyXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xyXG5cclxuZXhwb3J0IGNsYXNzIEFwaUdhdGV3YXlDaWNkRGVtb1N0YWNrIGV4dGVuZHMgY2RrLlN0YWNrIHtcclxuICBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wcz86IGNkay5TdGFja1Byb3BzKSB7XHJcbiAgICBzdXBlcihzY29wZSwgaWQsIHByb3BzKTtcclxuXHJcbiAgICBjb25zdCBlbnZTdGFnZSA9IHRoaXMubm9kZS50cnlHZXRDb250ZXh0KCdlbnYnKTtcclxuICAgIGlmICghZW52U3RhZ2UpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBjb250ZXh0IHZhcmlhYmxlICdlbnYnLiBVc2UgLS1jb250ZXh0IGVudj1kZXZ8c3RhZ2V8cHJvZFwiKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhcGlEZWZpbml0aW9uRGlyID0gcGF0aC5qb2luKF9fZGlybmFtZSwgJy4uL2FwaS1kZWZpbml0aW9uJyk7XHJcbiAgICBjb25zdCBlbnZQYXRoID0gcGF0aC5qb2luKGFwaURlZmluaXRpb25EaXIsIGAke2VudlN0YWdlfS5qc29uYCk7XHJcbiAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZW52UGF0aCkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGDinYwgT3BlbkFQSSBmaWxlIGZvciAnJHtlbnZTdGFnZX0nIG5vdCBmb3VuZDogJHtlbnZQYXRofWApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGFwaSA9IG5ldyBhcGlnYXRld2F5LlNwZWNSZXN0QXBpKHRoaXMsICdHbG9iYWxMb3lhbHR5QXBpJywge1xyXG4gICAgICBhcGlEZWZpbml0aW9uOiBhcGlnYXRld2F5LkFwaURlZmluaXRpb24uZnJvbUFzc2V0KGVudlBhdGgpLFxyXG4gICAgICByZXN0QXBpTmFtZTogJ0dsb2JhbExveWFsdHlBcGknLFxyXG4gICAgICBkZXBsb3lPcHRpb25zOiB7XHJcbiAgICAgICAgc3RhZ2VOYW1lOiBlbnZTdGFnZSxcclxuICAgICAgICB2YXJpYWJsZXM6IHtcclxuICAgICAgICAgIHBvaW50c1VybDogYGxveWFsdHktYmFja2VuZC0ke2VudlN0YWdlfS5pbnRlcm5hbGAsXHJcbiAgICAgICAgICB1c2Vyc1VybDogYHVzZXJzLXNlcnZpY2UtJHtlbnZTdGFnZX0uaW50ZXJuYWxgLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuICB9XHJcbn0qL1xyXG5cclxuXHJcbi8qXHJcbi8vIENvbW1lbnRlZCBhdCA4OjUwcG0gb24gMTUganVseSAyMDI1IFxyXG4vLyBsaWIvYXBpX2dhdGV3YXlfY2ljZF9kZW1vLXN0YWNrLnRzXHJcbmltcG9ydCAqIGFzIGNkayBmcm9tICdhd3MtY2RrLWxpYic7XHJcbmltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gJ2NvbnN0cnVjdHMnO1xyXG5pbXBvcnQgKiBhcyBhcGlnYXRld2F5IGZyb20gJ2F3cy1jZGstbGliL2F3cy1hcGlnYXRld2F5JztcclxuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xyXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xyXG5cclxuZXhwb3J0IGNsYXNzIEFwaUdhdGV3YXlDaWNkRGVtb1N0YWNrIGV4dGVuZHMgY2RrLlN0YWNrIHtcclxuICBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wcz86IGNkay5TdGFja1Byb3BzKSB7XHJcbiAgICBzdXBlcihzY29wZSwgaWQsIHByb3BzKTtcclxuXHJcbiAgICBjb25zdCBzdGFnZSA9IHRoaXMubm9kZS50cnlHZXRDb250ZXh0KCdlbnYnKTtcclxuICAgIGlmICghc3RhZ2UpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwi4p2MIE1pc3NpbmcgY29udGV4dCB2YXJpYWJsZSAnZW52Jy4gVXNlIC0tY29udGV4dCBlbnY9PHN0YWdlPlwiKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBlbnZQYXRoID0gcGF0aC5qb2luKF9fZGlybmFtZSwgYC4uL2FwaS1kZWZpbml0aW9uLyR7c3RhZ2V9Lmpzb25gKTtcclxuICAgIGlmICghZnMuZXhpc3RzU3luYyhlbnZQYXRoKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYOKdjCBPcGVuQVBJIGZpbGUgZm9yIHN0YWdlICcke3N0YWdlfScgbm90IGZvdW5kIGF0ICR7ZW52UGF0aH1gKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBvcGVuQXBpU3BlYyA9IEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKGVudlBhdGgsICd1dGY4JykpO1xyXG5cclxuICAgIC8vIENyZWF0ZSBzaW5nbGUgc2hhcmVkIEFQSSBHYXRld2F5XHJcbiAgICBjb25zdCBhcGkgPSBuZXcgYXBpZ2F0ZXdheS5SZXN0QXBpKHRoaXMsICdHbG9iYWxMb3lhbHR5QXBpJywge1xyXG4gICAgICByZXN0QXBpTmFtZTogJ0dsb2JhbExveWFsdHlBcGknLFxyXG4gICAgICBkZXNjcmlwdGlvbjogJ1NoYXJlZCBBUEkgR2F0ZXdheSBmb3IgYWxsIHN0YWdlcycsXHJcbiAgICAgIGRlcGxveTogZmFsc2UsIC8vIGRpc2FibGUgYXV0by1kZXBsb3ksIHdlIHdpbGwgbWFuYWdlIGl0IG1hbnVhbGx5XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBZGQgZHVtbXkgbWV0aG9kIHRvIGF2b2lkIHZhbGlkYXRpb24gZXJyb3JcclxuICAgIGFwaS5yb290LmFkZE1ldGhvZCgnR0VUJywgbmV3IGFwaWdhdGV3YXkuTW9ja0ludGVncmF0aW9uKHtcclxuICAgICAgaW50ZWdyYXRpb25SZXNwb25zZXM6IFt7IHN0YXR1c0NvZGU6IFwiMjAwXCIgfV0sXHJcbiAgICAgIHJlcXVlc3RUZW1wbGF0ZXM6IHsgXCJhcHBsaWNhdGlvbi9qc29uXCI6ICd7XCJzdGF0dXNDb2RlXCI6IDIwMH0nIH0sXHJcbiAgICB9KSwge1xyXG4gICAgICBtZXRob2RSZXNwb25zZXM6IFt7IHN0YXR1c0NvZGU6IFwiMjAwXCIgfV0sXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBEZXBsb3ltZW50ICYgc3RhZ2Ugc3BlY2lmaWMgY29uZmlndXJhdGlvblxyXG4gICAgY29uc3QgZGVwbG95bWVudCA9IG5ldyBhcGlnYXRld2F5LkRlcGxveW1lbnQodGhpcywgYERlcGxveW1lbnQtJHtzdGFnZX1gLCB7XHJcbiAgICAgIGFwaSxcclxuICAgIH0pO1xyXG5cclxuICAgIG5ldyBhcGlnYXRld2F5LlN0YWdlKHRoaXMsIGBTdGFnZS0ke3N0YWdlfWAsIHtcclxuICAgICAgZGVwbG95bWVudCxcclxuICAgICAgc3RhZ2VOYW1lOiBzdGFnZSxcclxuICAgICAgdmFyaWFibGVzOiB7XHJcbiAgICAgICAgcG9pbnRzVXJsOiBgbG95YWx0eS1iYWNrZW5kLSR7c3RhZ2V9LmludGVybmFsYCxcclxuICAgICAgICB1c2Vyc1VybDogYHVzZXJzLXNlcnZpY2UtJHtzdGFnZX0uaW50ZXJuYWxgLFxyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcbiAgfVxyXG59Ki9cclxuXHJcblxyXG4vKlxyXG4vLyBsaWIvYXBpX2dhdGV3YXlfY2ljZF9kZW1vLXN0YWNrLnRzXHJcbmltcG9ydCAqIGFzIGNkayBmcm9tICdhd3MtY2RrLWxpYic7XHJcbmltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gJ2NvbnN0cnVjdHMnO1xyXG5pbXBvcnQgKiBhcyBhcGlnYXRld2F5IGZyb20gJ2F3cy1jZGstbGliL2F3cy1hcGlnYXRld2F5JztcclxuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xyXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xyXG5cclxuZXhwb3J0IGNsYXNzIEFwaUdhdGV3YXlDaWNkRGVtb1N0YWNrIGV4dGVuZHMgY2RrLlN0YWNrIHtcclxuICBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wcz86IGNkay5TdGFja1Byb3BzKSB7XHJcbiAgICBzdXBlcihzY29wZSwgaWQsIHByb3BzKTtcclxuXHJcbiAgICBjb25zdCBlbnZTdGFnZXMgPSBbJ2RldicsICdzdGFnZScsICdwcm9kJ107XHJcbiAgICBjb25zdCBhcGlEZWZpbml0aW9uRGlyID0gcGF0aC5qb2luKF9fZGlybmFtZSwgJy4uL2FwaS1kZWZpbml0aW9uJyk7XHJcblxyXG4gICAgLy8gRHVtbXkgZGVwbG95bWVudCBhbmQgc3RhZ2UgdG8gc2F0aXNmeSBDREsgcmVxdWlyZW1lbnRcclxuICAgIGNvbnN0IGR1bW15RGVwbG95bWVudCA9IG5ldyBhcGlnYXRld2F5LkRlcGxveW1lbnQodGhpcywgJ0R1bW15RGVwbG95bWVudCcsIHtcclxuICAgICAgYXBpOiB1bmRlZmluZWQgYXMgYW55IC8vIHBsYWNlaG9sZGVyLCB3aWxsIG5vdCBiZSB1c2VkIHNpbmNlIGRlcGxveTogZmFsc2VcclxuICAgIH0pO1xyXG4gICAgY29uc3QgZHVtbXlTdGFnZSA9IG5ldyBhcGlnYXRld2F5LlN0YWdlKHRoaXMsICdEdW1teVN0YWdlJywge1xyXG4gICAgICBkZXBsb3ltZW50OiBkdW1teURlcGxveW1lbnQsXHJcbiAgICAgIHN0YWdlTmFtZTogJ3BsYWNlaG9sZGVyJyxcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEJhc2UgQVBJIHdpdGggZHVtbXkgc3RhZ2VcclxuICAgIGNvbnN0IGJhc2VBcGkgPSBuZXcgYXBpZ2F0ZXdheS5SZXN0QXBpKHRoaXMsICdHbG9iYWxMb3lhbHR5QXBpJywge1xyXG4gICAgICByZXN0QXBpTmFtZTogJ0dsb2JhbC1Mb3lhbHR5LU11bHRpU3RhZ2UnLFxyXG4gICAgICBkZXNjcmlwdGlvbjogJ0dsb2JhbCBMb3lhbHR5IEFQSSB3aXRoIE11bHRpLVN0YWdlIE9wZW5BUEkgU3BlY3MnLFxyXG4gICAgICBkZXBsb3k6IGZhbHNlLFxyXG4gICAgfSk7XHJcblxyXG4gICAgZm9yIChjb25zdCBlbnZTdGFnZSBvZiBlbnZTdGFnZXMpIHtcclxuICAgICAgY29uc3QgZW52UGF0aCA9IHBhdGguam9pbihhcGlEZWZpbml0aW9uRGlyLCBgJHtlbnZTdGFnZX0uanNvbmApO1xyXG4gICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZW52UGF0aCkpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oYOKaoO+4jyBTa2lwcGluZyAnJHtlbnZTdGFnZX0nIOKAkyBGaWxlIG5vdCBmb3VuZDogJHtlbnZQYXRofWApO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBvcGVuQXBpU3BlYyA9IEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKGVudlBhdGgsICd1dGY4JykpO1xyXG5cclxuICAgICAgY29uc3Qgc3BlY0FwaSA9IG5ldyBhcGlnYXRld2F5LlNwZWNSZXN0QXBpKHRoaXMsIGBTcGVjQXBpLSR7ZW52U3RhZ2V9YCwge1xyXG4gICAgICAgIGFwaURlZmluaXRpb246IGFwaWdhdGV3YXkuQXBpRGVmaW5pdGlvbi5mcm9tSW5saW5lKG9wZW5BcGlTcGVjKSxcclxuICAgICAgICBkZXBsb3k6IGZhbHNlLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbnN0IGRlcGxveW1lbnQgPSBuZXcgYXBpZ2F0ZXdheS5EZXBsb3ltZW50KHRoaXMsIGBEZXBsb3ltZW50LSR7ZW52U3RhZ2V9YCwge1xyXG4gICAgICAgIGFwaTogYmFzZUFwaSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBuZXcgYXBpZ2F0ZXdheS5TdGFnZSh0aGlzLCBgU3RhZ2UtJHtlbnZTdGFnZX1gLCB7XHJcbiAgICAgICAgZGVwbG95bWVudCxcclxuICAgICAgICBzdGFnZU5hbWU6IGVudlN0YWdlLFxyXG4gICAgICAgIHZhcmlhYmxlczoge1xyXG4gICAgICAgICAgcG9pbnRzVXJsOiBgbG95YWx0eS1iYWNrZW5kLSR7ZW52U3RhZ2V9LmludGVybmFsYCxcclxuICAgICAgICAgIHVzZXJzVXJsOiBgdXNlcnMtc2VydmljZS0ke2VudlN0YWdlfS5pbnRlcm5hbGAsXHJcbiAgICAgICAgfSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgbmV3IGNkay5DZm5PdXRwdXQodGhpcywgJ0Jhc2VBcGlJZCcsIHtcclxuICAgICAgdmFsdWU6IGJhc2VBcGkucmVzdEFwaUlkLFxyXG4gICAgfSk7XHJcbiAgfVxyXG59Ki9cclxuXHJcblxyXG5cclxuXHJcblxyXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cclxuLypcclxuaW1wb3J0IHsgU3RhY2ssIFN0YWNrUHJvcHMsIGF3c19hcGlnYXRld2F5IGFzIGFwaWd3IH0gZnJvbSAnYXdzLWNkay1saWInO1xyXG5pbXBvcnQgeyBDb25zdHJ1Y3QgfSBmcm9tICdjb25zdHJ1Y3RzJztcclxuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcclxuXHJcbmV4cG9ydCBjbGFzcyBBcGlHYXRld2F5Q2ljZERlbW9TdGFjayBleHRlbmRzIFN0YWNrIHtcclxuICBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBpZDogc3RyaW5nLCBwcm9wcz86IFN0YWNrUHJvcHMsIGVudk5hbWU/OiBzdHJpbmcpIHtcclxuICAgIHN1cGVyKHNjb3BlLCBpZCwgcHJvcHMpO1xyXG5cclxuICAgIGlmICghZW52TmFtZSkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBlbnZpcm9ubWVudCBuYW1lXCIpO1xyXG5cclxuICAgIGNvbnN0IHNwZWNQYXRoID0gcGF0aC5qb2luKF9fZGlybmFtZSwgJy4uJywgJ2FwaS1kZWZpbml0aW9uJywgYCR7ZW52TmFtZX0uanNvbmApO1xyXG5cclxuICAgIG5ldyBhcGlndy5TcGVjUmVzdEFwaSh0aGlzLCBgQXBpR3ctJHtlbnZOYW1lfWAsIHtcclxuICAgICAgYXBpRGVmaW5pdGlvbjogYXBpZ3cuQXBpRGVmaW5pdGlvbi5mcm9tQXNzZXQoc3BlY1BhdGgpLFxyXG4gICAgICBkZXBsb3lPcHRpb25zOiB7XHJcbiAgICAgICAgc3RhZ2VOYW1lOiBlbnZOYW1lLFxyXG4gICAgICAgIHZhcmlhYmxlczoge1xyXG4gICAgICAgICAgcG9pbnRzVXJsOiBgaHR0cHM6Ly8ke2Vudk5hbWV9LmFwaS5za2VjaGVycy5jb21gLCAvLyBvdmVycmlkZSBpZiBuZWVkZWRcclxuICAgICAgICAgIGNvbnRlbnRmdWxVcmw6IGBodHRwczovLyR7ZW52TmFtZX0uYXBpLnNrZWNoZXJzLmNvbWAsXHJcbiAgICAgICAgICB1c2Vyc1VybDogYGh0dHBzOi8vJHtlbnZOYW1lfS5hcGkuc2tlY2hlcnMuY29tYFxyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgcmVzdEFwaU5hbWU6IGBMb3lhbHR5QXBpLSR7ZW52TmFtZX1gLFxyXG4gICAgICBkZXNjcmlwdGlvbjogYEFQSSBHYXRld2F5IGZvciAke2Vudk5hbWV9IGVudmlyb25tZW50YCxcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG4qL1xyXG5cclxuaW1wb3J0IHsgU3RhY2ssIFN0YWNrUHJvcHMsIGF3c19hcGlnYXRld2F5IGFzIGFwaWd3LCBDZm5PdXRwdXQgfSBmcm9tICdhd3MtY2RrLWxpYic7XHJcbmltcG9ydCB7IENvbnN0cnVjdCB9IGZyb20gJ2NvbnN0cnVjdHMnO1xyXG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XHJcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XHJcblxyXG5leHBvcnQgY2xhc3MgQXBpR2F0ZXdheUNpY2REZW1vU3RhY2sgZXh0ZW5kcyBTdGFjayB7XHJcbiAgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgcHJvcHM/OiBTdGFja1Byb3BzKSB7XHJcbiAgICBzdXBlcihzY29wZSwgaWQsIHByb3BzKTtcclxuXHJcbiAgICBjb25zdCBhcGlfZGVmaW5pdGlvbiA9IHtcclxuICAgICAgZGV2OiAnZGV2Lmpzb24nLFxyXG4gICAgICBzdGFnZTogJ3N0YWdlLmpzb24nLFxyXG4gICAgICBwcm9kOiAncHJvZC5qc29uJ1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCByZXN0QXBpID0gbmV3IGFwaWd3LkNmblJlc3RBcGkodGhpcywgJ0xveWFsdHlSZXN0QXBpJywge1xyXG4gICAgICBuYW1lOiAnTG95YWx0eUFwaUdhdGV3YXknLFxyXG4gICAgICBkZXNjcmlwdGlvbjogJ1NpbmdsZSBBUEkgR2F0ZXdheSB3aXRoIG11bHRpcGxlIE9wZW5BUEktYmFzZWQgc3RhZ2VzJyxcclxuICAgICAgZmFpbE9uV2FybmluZ3M6IHRydWUsXHJcbiAgICAgIGVuZHBvaW50Q29uZmlndXJhdGlvbjoge1xyXG4gICAgICAgIHR5cGVzOiBbJ1JFR0lPTkFMJ11cclxuICAgICAgfSxcclxuICAgICAgYm9keTogSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMocGF0aC5qb2luKF9fZGlybmFtZSwgJy4uJywgJ2FwaV9kZWZpbml0aW9uJywgYXBpX2RlZmluaXRpb24uZGV2KSwgJ3V0ZjgnKSkgLy8gYW55IG9uZSB0byBpbml0aWFsaXplXHJcbiAgICB9KTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IFtlbnYsIGZpbGVuYW1lXSBvZiBPYmplY3QuZW50cmllcyhhcGlfZGVmaW5pdGlvbikpIHtcclxuICAgICAgY29uc3Qgc3BlY0JvZHkgPSBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYyhwYXRoLmpvaW4oX19kaXJuYW1lLCAnLi4nLCAnYXBpX2RlZmluaXRpb24nLCBmaWxlbmFtZSksICd1dGY4JykpO1xyXG5cclxuICAgICAgY29uc3QgZGVwbG95bWVudCA9IG5ldyBhcGlndy5DZm5EZXBsb3ltZW50KHRoaXMsIGBEZXBsb3ltZW50LSR7ZW52fWAsIHtcclxuICAgICAgICByZXN0QXBpSWQ6IHJlc3RBcGkucmVmLFxyXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgJHtlbnZ9IGRlcGxveW1lbnRgXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgbmV3IGFwaWd3LkNmblN0YWdlKHRoaXMsIGBTdGFnZS0ke2Vudn1gLCB7XHJcbiAgICAgICAgcmVzdEFwaUlkOiByZXN0QXBpLnJlZixcclxuICAgICAgICBkZXBsb3ltZW50SWQ6IGRlcGxveW1lbnQucmVmLFxyXG4gICAgICAgIHN0YWdlTmFtZTogZW52LFxyXG4gICAgICAgIHZhcmlhYmxlczoge1xyXG4gICAgICAgICAgcG9pbnRzVXJsOiBgJHtlbnZ9LmFwaS5za2VjaGVycy5jb21gLFxyXG4gICAgICAgICAgY29udGVudGZ1bFVybDogYCR7ZW52fS5hcGkuc2tlY2hlcnMuY29tYCxcclxuICAgICAgICAgIHVzZXJzVXJsOiBgJHtlbnZ9LmFwaS5za2VjaGVycy5jb21gXHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIG5ldyBDZm5PdXRwdXQodGhpcywgYFVybC0ke2Vudn1gLCB7XHJcbiAgICAgICAgdmFsdWU6IGBodHRwczovLyR7cmVzdEFwaS5yZWZ9LmV4ZWN1dGUtYXBpLiR7dGhpcy5yZWdpb259LmFtYXpvbmF3cy5jb20vJHtlbnZ9YFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbiJdfQ==